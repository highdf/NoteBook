### 进程

#### 进程的创建
进程创建的时机
- 系统启动时
- 一个进程请求创建另一个进程
- 用户通过命令创建一个进程
- 批处理执行作业的初始化


#### 进程的终止
进程的终止时机
- 正常结束
- 执行内部的误处理而结束程序
- 被另一个程序强行结束

#### 进程间的关联关系
由进程的创建操作构造出的进程关系是一种树状关系。每个父进程对应着多个子进程

#### 进程的状态
进程的状态有三种
- 就绪
- 运行
- 阻塞

这三种状态之间着四种转换关系
- 运行 -> 阻塞
- 阴塞 -> 运行
- 就绪 -> 运行

#### 进程之间的通信
实现进程通信的三个问题：

1. 如何实现进程A到进程B的通信
2. 如何解决在进程调度 + 共享内存通信方式下的进程兑争问题
3. 如何解决进程通信中保证进程间的依赖关系不变的问题

解决方案：

1. 关闭中断
    - 这个方法的想法是：即然兑争的原因是由于硬件中断时的调度行为造成的。那么，就在进入临界区时，关闭中断来解决这个问题。虽然这个方法确实可以解决资源兑鏽的问题。但是它又引入了一个严重的新问题。它就是将中断的控制权交给了用户，这寻致用户可以以此编富民一直抢占CPU的恶意程序。
2. 锁变量
    - 这个的想法是用一介共享变量来记录当前是否有进程在临区中。当A进程在临界区中之前，设置lock变量的值为1. 以使得B进程无法进入临界区。A进程离开临界区后，设置lock为0即可。
    - 这个方法的问题在于这个方法的具体实现上。它会先对锁变量执行条件判断，若为1,则进入死循环，等待锁释放。若为0,则离开循环。进入临界区，并设置锁变量为1。
    - 在这个实现中问题在于锁变量的判断与设置之间是可以被中断的。这导致A进入锁变量设置前，触发了中断，导致B也成功进入了临界区。
- 严格交替法
    - 这个方法的思想是使用一个变量记录当前是谁在临界区内。比如说用0记录A在临界区内，1记录B在临界区内。则A先判断变量是否为1.为1. 则死循环。为0,则进入临界区。在离开临界区时设置变量为1. 在B处先判断变量呇为0.为0.则死循环。为1.则进入临界区。离开后。设置变量为0.
    - 这个实现的问题在于，当A的离开临界区后，会将变量设置为1，为B使用。B进入临界区后。好快离开了。并设置变量为0,假设此时A还在非临界区。那么就会出现A在非临界区。B无法进入临界区的问题。
- Peterson方案
    - 地
- 硬件指令法
    - 这个方法提供了一个指令。这个指令的语义是获取一个变量的值，并为其设一个新值。这两个动作之间不可以被打断。

综上，以上的互斥方案中，都使用了“生旋等待"自旋式处理不在临界区中的线程。这种对非活动线程的处理，导致在某些条件 下，出现意外的情况。比如说：在优先级调度系统中，会出现死锁的情况，假设有A, B两个线程，其中A的优先级大于B线程的优先级，且A, B线程有一片共享空问。当前B线程在使用该共享空间，在之后的某段时间上，A线程被启动，此时调度器依据优先级，调度了A, 让B处于了就绪态。侱此时的问题在于B进程被抢占前并未释放lock, 这导致了A会一直自旋，且在优先调度中，B不会再被执行,最终A会一直自旋，导致整个系统坏掉。

我对”自旋等待“方式处理非活动线程的表述是否有问题？

```c
void producer (void) {
    item_t item = produc_itme();
    insert_buffer (item);
    count ++;
    if (count == N) {
        sleep (producer);
        wakeup (consummer)
    }
}

void consummer (void) {
    if (count == 0) {
        sleep (consummer)
        wakeup (producer)
    }
    remove_buffer();
    count --;
    if (count == 0) {
        sleep (consummer);
        wakeup (producer);
    }
}
```

### 睡眠与唤醒
sleep() 与 wakeup()的底层寮现，信号量有头的设计规则

#### 优先级反转问题
反转问题发生在一个使用优先级调度与自旋等待的环境中。例如：一个低级别的进程先执行，获取了锁，之后插入了一个优先级更高的进程，此时优先级调度系统将执行这个优先级更高的程序，但由于之前

#### 管程

#### 消息传递

#### 进程的调度

#### 线程
总结：存储硬件的实现原理与工作过程。
构成部分：信号存储器与转译器。
信号存储器：可持久某种物理信号的设备
转译器：可将存储器的物理信号转译为某种特定物理信号与根据特定的外部信号，修改存储器内信号的设备。

计算机的开机后，会有一个默认的引寻行为，实现这个行为的软件是属于计夅机的内置的部分吗？即不是由用户写入的？

引导程序的工作流程：
1. 计算机通电。CPU执行默认地址处的代码。即blos or uefi.
2. 固件被执行。它会先进行硬件自检，确定所有硬件可否可以正常工作。
2. 在硬件都没有问题后，它会执行硬件初始化。
4. 之后在进行操作系统引导查询。
5. 将控制权转交给操作系统引导程序。工作完毕。
我不理解在这个过程中为什么需要进行初始化。

为硬件配置内存地址是什么意思？

为梗件配置内存地址这个行为：可以解读为为梗件设置CPU可理解的标识符。这里的问题在于“CPU理解”是什么意思？
从人的生活中，我发现在使用理解这个词表达某种语义时，往往处在我知道了些什么的语义下。那么CPU知道什么呢？
CPU只知道预定义好的指令。因此对这些硬件进行交互可不可以使用这种预定义的指令的方式呢？

即如此为什么固件要使用为硬件设置内存地址的方式来标识硬件。为什么不使用特定的预定义指令来操作特定硬件？
因为使用后者简化了指令集设计, 统一个硬件的访问方式。

1. 进程与线程的本质别？
在早期进程的含义为：一个正在执行的程序，它包含其使用的各种数据，以及对这些数据执行的动作。
但后来进程的含义有了变化. 即程序在执行的过程中使用的关联的所有数据的标识。而将动作部分划分为多个相互独立的部分，并以线程为名。
引起这种变化的原因是什么呢？因为一个程序在执行的过程中会因为等侍仆部资源而进入阴塞态，同时一程序中存在相互独立的动作。因此就考虑使用并发这些相互独立的动作来填补阴塞动作的空闲。
反驳我的观点

#### question

调度算法的定性描述？

为什么需要调度算法？

什么是好的调度算法？

在批处理环境下FIFO夅法的优缺点分析

调度触发的时机，以及在这些时机触调度的合理性

实时操作系统的特点是什么？
