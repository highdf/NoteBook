### bomb解题思路

<!-- vim-markdown-toc GFM -->

* [前言](#前言)
* [实验环境](#实验环境)
* [准备](#准备)
* [汇编小结](#汇编小结)

<!-- vim-markdown-toc -->

#### 前言
- 这是一篇关于CSAPP中bomb实验的学习笔记，介绍了其中Phase_1~phase_5的解法，若有错漏，望不吝指正。  

#### 实验环境
- 虚拟机：VMware
- 操作系统：Ubuntu24.04
- 工具：
    1. vim
        - **介绍**：在终端高效编辑文本文件的编辑器  
        - **下载命令**：sudo apt install vim  
    2. gdb
        - **介绍**：在终端调试C语言可执行程序的调试器  
        - 下载命令：sudo apt install gdb  
    3. objdump
        - **介绍**：用于生成可执行文件的汇编代码  
        - 属于Ubntu系统预装程序，无需手动下载  
- 获取实验文件
```bash
wget https://csapp.cs.cmu.edu/3e/bomb.tar # 下载实验文件
tar -xvf bomb.tar && cd bomb # 解压并进入目录
```

#### 准备
- 文档阅读  
使用`vim bomb.c`查看`bomb`程序的大致执行过程。  
- 获取汇编文件
```bash
objdump -S bomb > bomb.s # 在当前目录下生成汇编文件bomb.s
```
- 查看结果  
使用命令`vim bomb.s`打开文件查看是否成功。如图：  
![image][start]
为了在测试过程中频繁的反复输入，可以创建一个`answer`文件，用于存放答案，测试时将其作为参数传递即可。  
```bash
touch answer # 创建参数文件
bomb answer  # 执行bomb，并传递参数answer
```

#### 汇编小结
在本节会简单介绍一些基本汇编指令的使用语法与语义。  

- 指令的一般格式
    1. 指令操作符 操作数0 操作数1 ...
    2. 指令操作符的作用是标识指令的具体行为。
    3. 操作数标识了指令操作的对象，一条完整的指令中操作数的数量会因操作符的不同而不同，在下文的具体指令的介绍中，读者可以看到有些指令需要两个操作数，有的只需要一个。

- 操作数语法与语义
    1. **常量**
        - 语法：在一条汇编指令文本中，常量使用`$`作为前缀，数值用十六进制表达。  
        - 语义：在`mov $0xa, %rsi`这条完整的汇编指令中，字符串`$0xa`的语义就是一个常量10。
    2. **寄存器**
        - 语法：使用`%`作为前缀符，后面紧跟一个寄存器的标识符。
        - 语义：在汇编指令`mov $0xb, %rsi`中，操作数`%rsi`的语义是使用寄存器`rsi`。
    3. **内存寻址**
        - 语法：内存寻址没有像寄存器那样使用字符串进行标识，而是通过内存地址来标识要访问的内存空间。文本格式为`offset(%a, %b, M)`，其中，`offset`是一个十六进制的字符串，表达一个数值。括号内`%a`称为基址寄存器，存储一个内存地址值。`%b`也是一个寄存器，称为变址寄存器。`M`是一个十六进制的字符串，表达一个数，称为比例常量。
        - 语义：汇编指令`mov 0xa(%rsi, %rdi, 2), %rax`中，字符串`0xa(%rsi, %rdi, 2)`标识一个内存地址，假设寄存器`%rsi`与`%rdi`的值是`0xffff0011`与`0x2`，则上述文本标识的内存地址是`0xffff0011+0x2*2+0xa`=`0xffff001f`，即最终使用的地址是`0xffff001f`

- 操作符
    1. 数据传输类
        - **MOV**
            1. 格式：MOV SRC, DET
            2. 作用：将源（SRC）写入目的（DET）中。
            3. 示例：`mov $0x7, %rax`。将源(0x7)写入目的寄存器rax中。`mov %rax, %rdi`，将源（寄存器rax中的值）写入目的寄存器rdi中。`mov 0x1(%rax, %rdi, 2), %rdi`，将计算式`%rax+%rdi*2+1`的值作为内存地址，并取对应内存单元内的数据作为源写入到寄存器%rdi中。以上是将寄存器作为目的，还可以将内存地址作为目的。
        - **LEA**
            1. 格式：LEA SRC, DET
            2. 作用：行为与MOV大部分相同，只有将内存寻址作为源的时候，LEA只计算地址不访问内存。
            3. 示例：`lea 0x2(%rax, %rdi, 2), %rdi`，将计算式`%rax+%rdi*2+2`的结果作为源，而非其指向内存单元中的数据。
    2. 算术运算类
        - **ADD**
            1. 格式：ADD SRC DET
            2. 作用：将`SRC+DET`的结果写入`DET`.
            3. 示例：`add $0x3, %rax`，将`0x3+%rax`的结果写入`%rax`中。
        - **SUB**
            1. 格式：SUB SRC DET
            2. 作用：将`DET-SRC`的值写入`DET`中。
            3. 示例：`sub $0xa, %rax`，将计算式`%rax-0xa`的结果写入`%rax`中。其他的操作数类同。
    3. 用户栈操作类
        - **PUSH**
            - 格式：PUSH SRC
            - 作用：将SRC写入栈顶指针所指向的内存单元。
            - 示例：`push $0xe`，将`0xe`写入栈顶指针`%rsp`所指向的内存单元。`push %rax`，将寄存器的值写入栈顶。
        - **POP**
            - 格式：POP DET
            - 作用：将栈顶元素写入DET中。
            - 示例：`pop %rax`，将栈顶元素写入`%rax`中。`pop (%rax)`，将栈顶元素写入计算式`%rax + 0*0 + 0`所指的内存单元中。
    4. 跳转类
        - **JMP**
            - 格式：JMP SRC
            - 作用：将下条要执行指令的地址设置为SRC。
            - 示例：`jmp 0x40234`，设置下条待执行指令的地址为`0x40234`。`jmp *(%rax)`，将计算式`%rax + 0*0 + 0`的结果作为地址值，设置下条指令的地址是对应内存单元中的值。
        - **CMP JXX**
            - 格式：CMP SRC, DET,JXX SRC
            - 作用：CMP用来设置条件码，JXX根据条件码与XX的值，执行相应的跳转。
            - 示例：`cmp $0x1, %rax,jle 0x40433`，XX为le时表示当rax-0x1的结果小于等于0时，执行跳转到SRC。反之，则不变。XX还有其他的值，感兴趣的读者可以自行搜索。

--- 

<!-- [start]: https://raw.githubusercontent.com/highdf/Picture/refs/heads/main/bomb/start.png -->
[start]: /home/luky/Pictures/Picture/bomb/start.png
